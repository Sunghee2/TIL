### Javascript

<hr/>
1. 데이터 타입

   - 할당이나 연산할 때

     - 기본형 : 값이 담긴 주소값을 바로 복제 - 불변성

       > number, string, boolean, null, undefined...

     - 참조형 : 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제

       > object, array, function, date, regExp, map, set...

   - 데이터 할당에 대한 메모리 영역

     | 주소(변수영역)    | 1002                | 1003   |
     | ----------------- | ------------------- | ------ |
     | 데이터            | 이름 : a 값 : @5003 |        |
     | 주소(데이터 영역) | 5002                | 5003   |
     | 데이터            |                     | 'abcd' |

     - 변수 영역에 직접 값을 대입하지 않는 이유는? (변수영역 / 데이터 영역이 나눠져 있는 이유는?)
       - 데이터 변환을 자유롭게 할 수 있음(공간을 가변적으로 쓸 수 있음)
       - 메모리 효율
       - 중복된 데이터 처리 효율 높아짐

   - 변수 / 상수 구분 - 변수 영역

     불변성 여부 구분 - 데이터 영역

     - 기본형 - 불변값

       ```javascript
       var a = 'abc'
       a = a + 'def';
       ```

       > 2번째 라인 실행시 'abc'에 'def'를 더하는 것이 아니라 'abcdef'를 새로 생성하여 그 주소를 변수 a에 저장함
       >
       > 즉, 불변성 = 기존에 있는 'abc'는 변하지 않음! 변할 때는 오로지 새로 만듦!
       
     - 참조형 - 가변 or 불변
     
       - 기본형과의 차이는 '객체의 변수 영역' 별도 존재 but 데이터 영역은 기존 메모리 공간 그대로 활용
     
         > 데이터 영역에 저장된 값은 모두 불변값. 하지만 변수에는 다른 값을 얼마든지 대입할 수 있다 => 참조형은 불변하지 않다고 함
     
       - 참조 카운트 : 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수
     
         > 참조 카운트가 0인 메모리 주소는 가비지 컬렉터에게 수거당함.
     
     - 변수 복사 - 복사할 때 변수 영역에 해당 이름을 찾아 값만 가져옴! 
     
       ```javascript
       var a = 10
       var b = a
       var obj1 = {c: 10, d: 'ddd'}
       var obj2 = obj1
       
       b = 15 // a !== b
       // 15를 찾아보고 없으면 새로 만들고, b를 찾아 값을 대입
       obj2.c = 20 // obj1 === obj2
       // 변수영역에서 c를 찾아 20이 있는 주소를 저장하게 되므로 둘 다 바뀜
       obj2 = {c: 20, d:'ddd'} // obj1 !== obj2
       // 참조형에서 가변은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립
       ```
     
       => 내부 프로퍼티를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당(spread operation, Object.assign) 해서 불변성 확보
     
       Q. 어떤 상황에 불변 객체가 필요할까? 
     
       > 값으로 전달받은 객체에 변경을 가하더라고 원본 객체는 변하지 않아야하는 경우
     
       - Shallow copy - 바로 아래 단계의 값만 복사
     
         > 저장된 프로퍼티를 복사할 때 그 주솟값만 복사함 => 원본 사본 모두 같은 주소 => 하나가 바뀌면 같이 바뀜
     
         Deep copy - 내부의 모든 값들을 하나하나 찾아서 전부 복사 - 불변객체
     
         1. 내부 프로퍼티를 순회하여 복사하는 함수 호출
     
         2. 객체를 Json 문자열로 전환했다가 다시 json 객체로 바꿈
     
            > 다만 함수나 __proto_나 getter/setter 과 같이 json으로 변경할 수 없는 것은 모두 무시됨.

   - undefined / null

     - undefined 

       1. 값을 대입하지 않은 변수

       2. 객체 내부에 존재하지 않는 프로퍼티에 접근할 때

          > 프로퍼티 개수만큼 빈공간을 확보하는 것이 아니라 특정 인덱스에 값을 지정할 때 빈 공간을 확보하여 저장하기 때문에 값이 지정되지 않은 인덱스는 아직 존재하지 않는 프로퍼티로 간주됨

       3. return 문이 없거나 호출되지 않는 함수의 실행결과

     - null : 비어있음을 명시적으로 나타내고 싶을 때

       - Type : object

   > 변수 : 변할 수 있는 수
   >
   > 식별자 : 변수명

   > 전역변수 최소화 노력
   >
   > 1. 즉시실행함수활용
   > 2. 네임스페이스
   > 3. 모듈패턴
   > 4. 샌드박스 패턴
   > 5. 모듈관리도구 ex) AMD, CommonJS, es6 모듈 등

   <br/>

   2. 실행 컨텍스트

      - 실행할 코드에 제공할 환경 정보를 모아놓은 객체

      - 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트로 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장

      - 구성하는 방법 - 함수 실행

        

      - VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷(내용 동일)으로, 변경 사항은 반영되지 않음

        - 최초 실행시의 스냅샷 유지
        - 실행 컨텍스트 생성할 때 variableEnvironment에 정보를 먼저 담은 다음, 그대로 복사해서 LexicalEnvironment를 만들고, 이후에는 LexicalEnvironment를 주로 활용
        - 둘 다 내부는 environmentRecord와 outer-EnvironmentReference로 구성

      - LexicalEnvironment : 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨

        - environmentRecord : 현재 컨텍스트와 관련된 코드의 식별자 정보 저장

          - 컨텍스트 내부 전체를 처음부터 끝까지 훑어나가며 순서대로 수집(코드 실행 전 상태) => 자바스크립트 엔진은 해당 환경에 속한 코드의 변수명들을 모두 알고 있게 됨

          - hoisting - 변수는 선언만 끌어올리지만 함수는 전체를 끌어올림

            > ```javascript
            > // 함수선언문
            > function a {}
            > 
            > // 함수 표현식 : 정의한 함수를 별도의 변수에 할당
            > var b = function() {}
            > var c = function d() {} // c()로 실행
            > ```
            >
            > 함수 선언문은 전체를 호이스팅한 반면 함수 표현식은 변수 선언부만 호이스팅함

          - 동일한 변수명에 서로 다른 값을 할당한 경우 나중에 할당한 값이 먼저 할당한 값을 덮어씌움(함수에서 주의) => 그래서 함수표현식을 사용해야함

        - Scope, outerEnvironmentReference

          - scope : 식별자에 대한 유효범위

            > es5이전에는 함수에 의해서만 스코프 생성(var)
            >
            > Es6, let, const는 블록에 의해서도 스코프 생성

          - Scope chain : 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것

          - outerEnvironmentReference : 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조

            > A함수 내부에 B 함수를 선언하고 다시 B 함수 내부에 C함수를 선언한 경우, 함수 C의 outerEnvironmentReference는 함수 B의 LexicalEnvironment를 참조

            - 가장 가까운 요소부터 차례대로만 접근할 수 있음

              > 변수 은닉화 : 만약 내부 함수에서 a 변수 선언하면 밖에 전역공간에 동일한 이름의 a 변수에 접근할 수 없음

      - ThisBinding : this 식별자가 바라봐야할 대상 객체

   <br/>

3. this - 함수를 호출할 때 결정

   - 전역 공간(전역 변수 선언)에서의 this - 전역 객체

   - 함수에서는 전역객체

   - method로 호출한 경우에는 . 앞에 있는 객체

   - new로 생성한 경우에는 자기 자신

     > 생성자의 prototype 프로퍼티를 참조하는 __proto_라는 프로퍼티가 있는 객체를 만들고, 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여

   - this 우회 방법

     - 변수로 객체를 저장함

     - this를 바인딩하지 않는 arrow function

       > 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠져 상위 스코프의 this를 그대로 활용

     - call, apply(배열) / bind

4. 콜백함수

   - 콜백 지옥
   - 비동기 : 현재 실행 중인 코드의 완료 여부와 무관하게 다음 코드로 넘어감

5. 클로저

   - 외부 함수의 LexicalEnvironment가 가비지 컬렉팅되지 않는 현상
   - 메모리 관리
     - 안 쓰는 것은 참조카운트 0으로 만들기 - 식별자에 참조형이 아닌 기본형 데이터(null or undefined)를 할당
   - 활용 사례
     - 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때
     - 접근 권한 제어(정보 은닉) : 어떤 모듈의 내부 로직에 대해 외부로의 노출을 최소화해서 모듈간의 결합도를 낮추고 유연성을 높이고자 함
     - 부분 적용 함수 : 일부 파라미터만 미리 저장했다가 나중에 호출할 때 나머지 받음
     - 커링 함수 : 여러개 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성한 것(ex) 화살표 함수)
       - 한 번에 하나의 인자만 전달하는 것을 원칙
       - 당장 필요한 정보만 받아서 전달하고 또 필요한 정보가 들어오면 전달하는 식으로 하면 결국 마지막 인자가 넘어갈 때까지 함수 실행을 미루는 셈

6. 프로토 타입

   > 클래스 기반 언어에서는 상속을 사용하지만 프로토타입 기반 언어에서는 어떤 객체를 프로토타입으로 삼고 이를 복제(참조)함으로써 상속과 비슷한 효과를 얻음

   - 프로토타입 체인 : 어떤 데이터의 ` __proto__`프로퍼티 내부에 다시 __proto_ 프로퍼티가 연쇄적으로 이어진 것

     프로토타입 체이닝 : 이 체인을 따라가며 검색하는 것

   - static method : 인스턴스에서 직접 접근할 수 없는 메서드(생성자 함수에 직접 정의한 메서드)

     > ex) Object.freeze
     >
     > instance.freeze => instance.`__proto__`.freeze가 아님.
     >
     > Object.prototype이 아닌 Object에 직접 부여하여 객체에서만 동작하도록 함. 

     - Object.prototype은 다른 곳에서 쓸 수 있어 범용적인 메서드들 있음(toString, valueOf 등)
     - 프로토타입 메서드 : 인스턴스에서 직접 호출할 수 있는 메서드(prototype 내부에 정의된 메소드)

<br/>

7. 클래스

   - 클래스 : 어떤 사물의 공통 속성을 모아 정의한 추상적인 개념

     인스턴스 : 클래스의 속성을 지닌 구체적인 사례

   - 프로토타입 체인을 활용해 클래스 상속 구현

<hr/>

#### Typescript

- 컴파일 언어, 정적 타입 언어이다. JS는 인터프리터 언어지만, TypeScript는 컴파일 언어로 코드 수준에서 미리 타입을 체크하여 오류를 체크해낸다. 단 전통적인 컴파일 언어와는 다르게, 링킹 과정이 생략되어 있다.
- 타입 기반 언어로써
  - 타입 스크립트 = 자바스크립트 + 타입
  - 컴파일 단계에서 타입 오류를 잡아낼 수 있고, 코드 어시스트 기능도 지원받을 수 있다.
  - 이것을 통해 암묵적 형변환, 호이스팅, 복잡성 문제를 해결할 수 있다.

- 장점

  - 에러를 줄일 수 있고(런타임이 아닌 컴파일 단계에서 에러를 잡을 수 있음) 코드 의도가 분명해짐/안정성이 확보

  - type에 대한 예외 처리를 하지 않아도 된다

  - Private, protected 등의 접근 제한자, 추상클래스, 인터페이스, 제네릭, 데코레이터 등 기능 제공 => 구조 설계, 모듈화, 객체 지향 측면에서 js보다 활용도 높음

  -  JS엔진의 최적화를 돕는다. JS엔진은 hot function(자주 호출되는 함수)에 대해 최적화를 수행한다.

    ```js
    var add = (a,b) => a+b;
    `
    ```

    JS엔진은 위 함수가 자주 호출되며, 인자 a,b가 정수형으로 들어오는 것을 확인했다. 엔진은 '아! 앞으로도 a,b는 정수가 들어오는구나 라고 가정을 하고 최적화를 수행하는데 갑자기 string이 들어오면 최적화가 해체된다. 이런 최적화와 해체 작업이 반복되면 성능이 저하되므로 TS에서는 type을 지정하고 컴파일 과정에서 검사하기 때문에 최적화 해체가 발생할 상황이 적어진다.

- 단점

  - 타입 선언 초기 비용

> 정적 언어
>
> - 타입을 컴파일 시에 결정
> - 장점
>   - 타입에 대한 정보를 컴파일(고급언어를 기계어로 변경)할 때 결정하기 때문에 속도 
>   - 타입 안정성
>
> 동적 언어
>
> - 실행 시에 타입 결정
> - 장점
>   - 런타임(어떤 프로그램의 실행)까지 타입에 대한 결정을 끌고 갈 수 있어 선택의 여지가 넓음
> - 단점
>   - 타입 에러

