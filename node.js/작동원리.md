## javascript engine

- Javascript 코드를 실행하는 프로그램 or 인터프리터

- google V8 engine - chrome, node.js 에서 사용

  ![img](https://miro.medium.com/max/1600/1*X21ybPxqBtfRV5v9rD9J1A.png)

  - Memory heap : 메모리 할당이 이루어지는 곳입니다.
  - call stack : 코드가 실행되면서 스택 프레임이 쌓이는 곳입니다.

## runtime

![img](https://miro.medium.com/max/1600/1*i9nTlOSPH3q-sCd5-WHg-g.png)

- Web APIs : 브라우저가 제공 ex) DOM, Ajax, `setTimeout` 

## Call stack

- javascript - single thread === call stack이 1개 (한 번에 일 1개만 처리)
- stack frame : call stack의 각각
- 재귀함수로 overflow가 나게 되면 다른 코드는 실행X => asynchronous callback 등장

## Event loop

- event loop는 가능하다면 언제나 시스템 커널에 작업을 떠넘겨서 Node.js가 non-blocking I/O 작업을 수행하도록 해줌 (JavaScript가 싱글 스레드임에도 불구하고)

  > 대부분은 멀티 스레드이므로 백그라운드에서 다수의 작업을 실행할 수 있습니다. 이러한 작업 중 하나가 완료되면 커널이 Node.js에게 알려주어 적절한 콜백을 **poll** queue에 추가할 수 있게 하여 결국 실행되게 합니다. 

  

  Node.js를 시작할 때 이벤트 루프를 초기화하고 제공된 입력 스크립트를 처리합니다. 이때 이 스크립트는 비동기 API를 호출하거나 스케줄링된 타이머를 사용하거나 `process.nextTick()`를 호출할 수 있습니다. 그다음 이벤트 루프 처리를 시작합니다.

  아래 다이어그램은 이벤트 루프의 작업 순서의 간단한 개요를 보여줍니다.

  각 단계는 실행할 콜백의 FIFO 큐를 가집니다. 각 단계는 자신만의 방법에 제한적이므로 보통 이벤트 루프가 해당 단계에 진입하면 해당 단계에 한정된 작업을 수행하고 큐를 모두 소진하거나 콜백의 최대 개수를 실행할 때까지 해당 단계의 큐에서 콜백을 실행합니다. 큐를 모두 소진하거나 콜백 제한에 이르면 이벤트 루프는 다음 단계로 이동합니다.

  이러한 작업이 *또 다른* 작업을 스케줄링하거나 **poll** 단계에서 처리된 새로운 이벤트가 커널에 의해 큐에 추가될 수 있으므로 폴링 이벤트를 처리하면서 poll 이벤트를 큐에 추가할 수 있습니다. 그 결과 오래 실행되는 콜백은 poll 단계가 타이머의 한계 시점보다 훨씬 더 오래 실행되도록 할 수 있습니다. 자세한 내용은 [**timers**](https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/#timers)와 [**poll**](https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/#poll)을 참고하세요.

  

- javascript 코드를 실행하며 파일 I/O와 같은 값비싼 작업을 처리할 수 있는 worker pool 제공

- event에 대해 등록된 javascript callback을 실행하며, 네트워크 I/O와 같은 비차단 비동기 요청을 이행하는 역할

- call stack과 callback queue를 모니터링하는 작업

  - call stack이 비어있으면 queue의 첫번째 event 가 call stack에 전달되어 효과적으로 실행됨

  - 이런 반복을 event loop의 tick이라고 함. 각 event는 단지 callback 함수임

- Worker pool

  - libuv에서 구현



이벤트 루프 및 작업자 풀 차단을 방지해야 하는 이유
노드는 적은 수의 스레드를 사용하여 많은 클라이언트를 처리한다. 노드에는 하나의 이벤트 루프(주 루프, 주 스레드, 이벤트 스레드 등)와 작업자 풀(스레드풀)의 k 작업자 풀(스레드풀)의 두 가지 유형의 스레드가 있다.

스레드가 콜백(이벤트 루프)이나 작업(작업자)을 실행하는 데 오랜 시간이 걸리는 경우, 우리는 그것을 "차단"이라고 부른다. 한 클라이언트를 대신하여 작업하는 스레드는 차단되지만 다른 클라이언트의 요청은 처리할 수 없다. Event Loop과 Worker Pool을 모두 차단하는 두 가지 동기를 제공한다.

성능: 두 유형의 스레드에 대해 정기적으로 헤비급 작업을 수행하면 서버의 처리량(요청/초)이 저하된다.
보안: 특정 입력에 대해 당신의 스레드 중 하나가 차단될 가능성이 있는 경우, 악의적인 클라이언트는 이 "악성 입력"을 제출하고 당신의 스레드를 차단하고 다른 클라이언트에서 작업하지 못하게 할 수 있다. 이것은 서비스 거부 공격일 것이다.



노드는 이벤트 기반 아키텍처를 사용하며, 오케스트레이션을 위한 이벤트 루프와 값비싼 작업을 위한 작업자 풀을 가지고 있다.

이벤트 루프에서 실행되는 코드
노드 애플리케이션이 시작되면 먼저 초기화 단계를 완료하고, 모듈 요구 및 이벤트에 대한 콜백을 등록하십시오. 노드 애플리케이션은 이벤트 루프에 들어가 적절한 콜백을 실행하여 들어오는 클라이언트 요청에 응답한다. 이 콜백은 동기적으로 실행되며, 완료 후 처리를 계속하기 위한 비동기 요청을 등록할 수 있다. 이러한 비동기 요청에 대한 콜백은 이벤트 루프에서도 실행된다.



실제로 V8 엔진에는 이벤트 루프를 관리하는 코드가 없다. Node.js나 브라우저가 이벤트 루프를 담당하는 것)

https://nodejs.org/ko/docs/guides/dont-block-the-event-loop/

Event Loop은 각각의 새로운 클라이언트 연결을 알아차리고 응답의 생성을 조정한다. 모든 수신 요청 및 발신 응답은 이벤트 루프를 통해 전달된다. 즉, 이벤트 루프가 어느 시점에서든 너무 오래 소비하면 현재와 신규 고객 모두 전환이 되지 않는다.

이벤트 루프를 막지 않도록 해야 한다. 즉, 각 JavaScript 콜백은 빠르게 완료되어야 한다. 

이를 확실히 하는 좋은 방법은 콜백(callback)의 "컴퓨팅 복잡성"에 대해 생각해 보는 것이다. 만약 당신의 콜백이 그것의 주장이 무엇이든 간에 일정한 수의 단계를 밟는다면, 당신은 항상 보류 중인 모든 고객들에게 공평한 태도를 줄 것이다. 만약 당신의 콜백이 그것의 주장에 따라 다른 수의 단계를 밟는다면, 당신은 그 주장이 얼마나 길지 생각해봐야 한다.

예 1: 일정 시간 콜백.



노드는 하나의 이벤트 루프와 k worker라는 두 가지 유형의 스레드를 가지고 있다. 이벤트 루프(Event Loop)는 JavaScript 콜백과 비차단 I/O를 담당하며, 작업자는 I/O 차단, CPU 집약적인 작업 등 비동기 요청을 완료하는 C++ 코드에 해당하는 작업을 실행한다. 



- es6에서는 event loop가 작동하는 방식을 지정함. (이벤트 루프 queue에 대한 스케줄 작업에 대한 직접적이고 세분화된 제어에 대한 접근이 필요하기 때문에 es6부터 promise 도입)



NodeJS에서는 **event queue**와 **event loop**를 사용해서 많은 callback function들을 처리한다.

서버는 I/O요청을 받아서 HardDisk나, Network Device에게 일을 시키고 그 일이 끝나면 event queue 에 (개발자가) 설정해 놓은 callback function을 순서대로 담고, event loop는 그 callback function을 하나하나 빼서 실행한다.



## Event Queue는 하나가 아니다

네트워크 관련 I/O 작업들은 주로 OS를 통해서 OS의 프로세스 자원을 사용하여 처리되며, 파일 입출력 및 암호만들기 등은 [libuv](http://libuv.org/)라는 멀티 플랫폼 비동기 I/O처리 라이브러리의 Thread Pool안에있는 thread에서 처리를 해준다. 타이머는 **이벤트 루프안에서** [정해진 시간이 지났는지를 계속 체크한다](https://github.com/nodejs/node/blob/70ab3108e2d8fa0947a62f8e41675ca1efd160fb/deps/uv/src/timer.c#L169)(따로 thread나 OS의 기능을 사용해서 돌리는것 같지는 않다).



### Event Queue

1. timers : setTimeout(), setInterval()로 등록한 callback 함수와 호출 시간이 들어있다. event loop는 timers queue에 들어있는 타이머 아이템(callback 함수 , 호출시간)에 설정된 호출시간이 지났는지 판단해서 callback function을 호출한다.

   ## setTimeout(cb, 0)은 0초후에 실행되지 않는다

   setTimeout(cb)은 timer queue에 들어가있을테지만, loop가 딱 1초가 지나는 순간에 timer queue에서 딱 1초가 지났는지 판별해서 cb을 호출하기는 어렵기 때문이다(확률이 매우 낮을것으로 예상). 저 1000은 단지, **최소한 1초안에는 호출되지 않는다**는걸 보장할 뿐이다.

   

2. **I/O events** : I/O 작업이 끝난후에 호출될 callback function이 들어있다.

3. **Immediates** : setImmediate()로 설정된 callback function이 들어있다.

4. **close handler** : *.on(‘close’)로 설정된 callback function이 들어있다.



> ## setTimeout() vs setImmediate()
>
> ```
> setTimeout(function(){
>  console.log("Timeout");
> }, 1000);
> 
> setImmediate(function(){
>  console.log("Immedate");
> });
> ```
>
> 1. setTimeout()이 실행되고 cb이 timer queue에 들어간다
> 2. setImmediate()가 실행되고 cb이 immediate queue에 들어간다
> 3. 루프를 돌리기 시작하고, timer queue에 있는 cb은 아직 1초가 지나지 않았기 때문에 실행되지 않는다
> 4. 다른 phase를 지나 immediate queue에 들어있는 cb펑션을 호출한다
> 5. 한바퀴 돌았으니까 이제 다시 timer queue를 돌고 이제, 첨에 등록해놨던 setTimeout(cb)이 실행된다
> 6. output이 항상 같다
>
> 이번엔 setTimeout(cb)가 **0초**후에 실행되도록 해보았다
>
> ```
> //index.js
> setTimeout(function(){
>     console.log("Timeout");
> }, 0);
> setImmediate(function(){
>     console.log("Immediate");
> });
> ```
>
> 1. setTimeout()이 실행되고 cb가 timer queue에 들어간다
> 2. setImmediate()가 실행되고 cb가 immediate queue에 들어간다
> 3. 루프를 돌리기 시작하고, timer queue에 있는 cb펑션은 0초가 지났기 때문에 호출된다
> 4. 다른 phase를 지나 immediate queue에 들어있는 cb펑션을 호출한다
> 5. output이 **항상 일정하게 출력되지는 않는다**. 왜냐하면 0초후에 실행하라고 명령해도 [내부적으로는 1ms로 설정된다고 한다](https://drive.google.com/open?id=1Cj19CrEfGfuOvddmA_GYN5wmnQvbera_). 따라서 시스템상 1ms가 안지났다고 판단해서, 해당 cb이 호출되지 않고 다음 phase로 넘어갈 수 있기 때문이다.
>
> `setTimeout()`보다 `setImmediate()`를 사용할 때 가장 큰 장점은 `setImmediate()`가 얼마나 많은 타이머가 존재하냐에 상관없이 I/O 주기 내에서 스케줄된 어떤 타이머보다 항상 먼저 실행된다는 것입니다.
>
> 1. `fs.readFile`을 만나면 이벤트 루프는 libUV에게 해당 작업을 던짐.
> 2. 파일 읽기는 OS 커널에서 비동기 API를 제공하지 않기 때문에 libUV는 별도의 스레드에 해당 작업을 던짐
> 3. 작업이 완료되면 이벤트 루프는 `Pending i/o callback phase`의 `pending_queue`에 작업의 콜백을 등록
> 4. 이벤트 루프가 `Pending i/o callback phase`를 지날 때 해당 콜백을 실행
> 5. `setTimeout`이 `Timer phase`의 큐에 등록됨. 해당 콜백은 다음 `Timer phase` 때 실행될 것이다.
> 6. `setImmediate`의 콜백이 `Check phase`의 `check_queue`에 등록됨.
> 7. `Poll phase`에서는 딱히 할 일이 없지만, `Check phase`의 큐에 작업이 있으므로 바로 `Check phase`로 이동
> 8. setImmediate 콘솔 출력. `Timer phase`에는 타이머가 등록되어 있으므로 다시 이벤트 루프가 시작된다.
> 9. `Timer phase`에서 타이머를 검사, 딜레이가 0이므로 `setTimeout`의 콜백을 바로 실행한다.
> 10. setTimeout 콘솔 출력
>
> 즉, 이런 과정을 거치기 때문에 `setImmediate`의 콜백이 반드시 `setTimeout`보다 먼저 실행되는 것을 보장할 수 있는 것이다.

> ## setTimeout() vs setImmediate() vs process.nextTick()
>
> ```
> setImmediate(() => console.log('this is set immediate 1'));
> setImmediate(() => console.log('this is set immediate 2'));
> setImmediate(() => console.log('this is set immediate 3'));
> 
> setTimeout(() => console.log('this is set timeout 1'), 0);
> setTimeout(() => {
>  console.log('this is set timeout 2');
>  process.nextTick(() => console.log('this is process.nextTick added inside setTimeout'));
> }, 0);
> setTimeout(() => console.log('this is set timeout 3'), 0);
> setTimeout(() => console.log('this is set timeout 4'), 0);
> setTimeout(() => console.log('this is set timeout 5'), 0);
> 
> process.nextTick(() => console.log('this is process.nextTick 1'));
> process.nextTick(() => {
>  process.nextTick(console.log.bind(console, 'this is the inner next tick inside next tick'));
> });
> process.nextTick(() => console.log('this is process.nextTick 2'));
> process.nextTick(() => console.log('this is process.nextTick 3'));
> process.nextTick(() => console.log('this is process.nextTick 4'));
> 
> 
> // output
> 
> // this is process.nextTick 1
> // this is process.nextTick 2
> // this is process.nextTick 3
> // this is process.nextTick 4
> // this is the inner next tick inside next tick
> // this is set timeout 1
> // this is set timeout 2
> // this is set timeout 3
> // this is set timeout 4
> // this is set timeout 5
> // this is process.nextTick added inside setTimeout
> // this is set immediate 1
> // this is set immediate 2
> // this is set immediate 3
> ```
>
> 1. setImmediate(cb)가 immediate queue에 들어간다
> 2. setTimeout(cb) 가 timer queue에 들어간다
> 3. process.nextTick(cb) 가 next tick queue에 들어간다
> 4. 루프가 timer phase로 가기전에 next tick queue를 **먼저** 돈다
> 5. 두번째 process.nextTick(cb)이 호출될때 안에서 한번더 process.nextTick()이 호출되었기 때문에, next tick queue 에 하나가 더 쌓인다. 이거는 네번째 process.nextTick(cb)이 호출되고 나서 호출된다(=> this is the inner next tick inside next tick)
> 6. 이제 next tick queue가 비었으므로, timer queue를 돌기 시작한다
> 7. 모든 setTimeout(cb)이 0초후에 실행되도록 설정되었고, next tick queue를 도는동안 최소 1ms는 지났기 때문에 timer queue에 있는 모든 cb을 호출한다
> 8. 두번째 setTimeout(cb)이 호출될때 process.nextTick()을 호출했기 때문에, next tick queue에 cb이 하나 들어가진다
> 9. timer queue를 다 돌고 i/o event queue 에 들어가기에 앞서 next tick queue를 한번 검사한다. 안에 방금전 두번째 setTimeout()에서 등록한 cb이 있기 때문에 그걸 호출한다( => this is process.nextTick added inside setTimeout)
> 10. i/o event queue에 pending cb도 없고, i/o polling할것도 없기 때문에 immediate queue로 넘어간다. 코드의 맨 처음 설정한 setImmediate(cb)부터 하나씩 호출한다

> ````
> const fs = require('fs');
> 
> fs.readFile('hello.txt', () => {
> setTimeout(() => {
>  console.log('timeout')
> }, 0);
> setImmediate(() => {
>  console.log('immediate')
> });
> });
> 
> 
> // output
> 
> // immediate
> // timeout
> ````
>
> 1. readFile()이 실행되고 다른 일이 없으니까 main thread는 hello.txt가 읽히기를 기다리고(i/o polling) 다 읽혀지면, cb을 호출한다
> 2. timer queue에 하나 담기고, immediate queue에 하나 담긴다
> 3. timer phase -> i/o polling -> immediate phase 순서기 때문에, 언제나 setImmediate(cb)가 먼저 호출된다. 다시말해서 전체적으로는 timer queue에 도 cb이 있고 immediate queue에도 cb이 있지만, i/o polling다음에 살펴볼 queue가 immediate기 때문에 setImmediate(cb)가 호출되는것이다.

## Event Loop Phases

event loop는 libuv의 [uv_run()](https://github.com/nodejs/node/blob/70ab3108e2d8fa0947a62f8e41675ca1efd160fb/src/node.cc#L2893)에서 시작된다. 그리고 그 안에서 특별한 역할을 담당하는 함수들이 아래 이미지와 같은 **순서대로** 호출된다. 각각의 함수 혹은 단계를 phase라고 부른다.

![img](https://miro.medium.com/max/1516/1*KoJw4CXQo8-OLbToOK5CPA.png)

(1) [**timers**](https://github.com/nodejs/node/blob/70ab3108e2d8fa0947a62f8e41675ca1efd160fb/deps/uv/src/unix/core.c#L361) : timer event queue를 한바퀴 돌면서 지연 시간이 지난 타이머들의 callback function을 호출한다.

타이머는 사람이 *실행하기를 원하는* **정확한** 시간이 아니라 제공된 콜백이 *일정 시간 후에 실행되어야 하는* **기준시간**을 지정합니다. 타이머 콜백은 지정한 시간이 지난 후에 스케줄링 될 수 있는 가장 이른 시간에 실행될 것입니다. 하지만 운영체제 스케줄링이나 다른 콜백 실행 때문에 지연될 수 있습니다.

***Note**: 기술적으로는 [**poll** 단계](https://nodejs.org/ko/docs/guides/event-loop-timers-and-nexttick/#poll)에서 타이머를 언제 실행할지 제어합니다.*

예를 들어, 100ms 임계 값 이후에 실행되도록 만료시간을 지정하면 스크립트는 95ms가 걸리는 파일 읽기를 비동기로 시작합니다.

```javascript
const fs = require('fs');

function someAsyncOperation(callback) {
  // 이 작업이 완료되는데 95ms가 걸린다고 가정합니다.
  fs.readFile('/path/to/file', callback);
}

const timeoutScheduled = Date.now();

setTimeout(() => {
  const delay = Date.now() - timeoutScheduled;

  console.log(`${delay}ms have passed since I was scheduled`);
}, 100);

// 완료하는데 95ms가 걸리는 someAsyncOperation를 실행합니다.
someAsyncOperation(() => {
  const startCallback = Date.now();

  // 10ms가 걸릴 어떤 작업을 합니다.
  while (Date.now() - startCallback < 10) {
    // 아무것도 하지 않습니다.
  }
});
```



이벤트 루프가 **poll** 단계에 진입했을 때 빈 큐를 가지고 있으므로(`fs.readFile()`이 아직 완료되지 않았습니다.) 가장 빠른 타이머의 임계 값에 도달할 때까지 수 밀리 초 기다릴 것입니다. 95ms가 지나기를 기다리는 동안 `fs.readFile()`이 파일 읽기를 끝마치고 완료하는데 10ms가 걸리는 콜백이 **poll** 큐에 추가되어 실행됩니다. 콜백이 완료되었을 때 큐에 있는 콜백이 없으므로 이벤트 루프는 가장 빠른 타이머의 임계 값에 도달했는지를 확인하고 타이머의 콜백을 실행하려고 **timers** 단계에 되돌아갑니다. 이 예제에서 타이머가 스케줄링되고 콜백이 실행되기까지의 전체 지연시간이 105ms가 되는 것을 볼 수 있습니다.

Note: **poll** 단계가 이벤트 루프를 모두 차지하지 않게 하기 위해 [libuv](https://libuv.org/)(Node.js 이벤트 루프와 플랫폼의 모든 비동기 동작을 구현한 C 라이브러리)도 더 많은 이벤트를 폴링하기를 멈추는 하는 하드 최댓값(시스템에 따라 다릅니다.)도 가집니다.

`Timer phase`는 이벤트 루프의 시작을 알리는 페이즈이다. 이 페이즈가 가지고 있는 큐에는 `setTimeout`이나 `setInterval` 같은 타이머들의 콜백을 저장하게 된다. 이 페이즈에서 바로 `타이머들의 콜백`이 큐에 들어가는 것은 아니지만 `타이머`들을 `min-heap`으로 유지하고 있다가 실행할 때가 된 타이머들의 콜백을 큐에 넣고 실행하는 것이다.

(2) [**pending callbacks**](https://github.com/nodejs/node/blob/70ab3108e2d8fa0947a62f8e41675ca1efd160fb/deps/uv/src/unix/core.c#L362) : pending queue에 있는 callback function들을 처리한다. 아마도 I/O Operation의 결과값들(ex. network I/O)혹은 그것의 주소값을 같이 갖고있을것 같다. 그래야 callback function호출할때 인자값에 넣을 수 있기 때문이다. poll단계에서 처리되지 못한(다음 루프로 지연시킨) callback function들이 이곳에 담겨있을 것이다.

이 단계에서는 TCP 오류 같은 시스템 작업의 콜백을 실행합니다. 예를 들어 TCP 소켓이 연결을 시도하다가 `ECONNREFUSED`를 받으면 일부 *nix 시스템은 오류를 보고하기를 기다리려고 합니다. 이는 **pending callbacks** 단계에서 실행되기 위해 큐에 추가될 것입니다.

이 페이즈에서는 이벤트 루프의 `pending_queue`에 들어있는 콜백들을 실행한다. 이 큐에 들어와있는 콜백들은 현재 돌고 있는 루프 이전에 한 작업에서 이미 큐에 들어와있던 콜백들이다. 예를 들어 여러분이 TCP 핸들러 콜백 함수에서 파일에 뭔가를 썼다면 TCP 통신이 끝나고 파일 쓰기도 끝나고 나서 파일 쓰기의 콜백이 이 큐에 들어오는 것이다.(파일 쓰기는 보통 비동기로 이루어진다.) 또한 에러 핸들러 콜백도 `pending_queue`로 들어오게 된다.

(3) [**idle**](https://github.com/nodejs/node/blob/70ab3108e2d8fa0947a62f8e41675ca1efd160fb/deps/uv/src/unix/core.c#L363) : uv_idle_{init,start,stop} API를 사용해여idle queue에 등록된 callback function을 호출한다. (용도를 모르겠다)

이름은 `Idle phase`이지만 이 페이즈는 매 Tick마다 실행된다. `Prepare phase` 또한 매 폴링(Polling)때마다 실행된다. 어쨌든 이 두개의 페이즈는 이벤트 루프와 직접적인 관련이 있다기보다는 Node.js의 내부적인 관리를 위한 것이기 때문에 이 포스팅에서는 설명하지 않는다.

(4) [**prepare**](https://github.com/nodejs/node/blob/70ab3108e2d8fa0947a62f8e41675ca1efd160fb/deps/uv/src/unix/core.c#L364) : uv_prepare_{init,start,stop} API를 사용하여 prepare queue에 등록된 callback function을 호출한다. poll phase에서 loop가 잠깐 block될 수 있기 때문에, block되기 전에 실행할것들이 여기에서 실행된다.

(5) [**poll**](https://github.com/nodejs/node/blob/70ab3108e2d8fa0947a62f8e41675ca1efd160fb/deps/uv/src/unix/core.c#L370) : 여유가 있다면 I/O Operation이 끝나기를 기다린다. 이렇게 기다리다가 어떤 I/O Operation이 끝나면 pending queue에 넣지 않고 여기서 바로 실행한다. 예를들어, 다음 타이머가 실행되기 까지 10초가 남았고 다른 큐에는 할일이 없다면, 10초동안 I/O Operation(파일 읽기, 쓰기)이 끝나기를 기다린다.

이 페이즈에서는 새로운 수신 커넥션(새로운 소켓 설정 등)과 데이터(파일 읽기 등)를 허용한다. 우리는 여기서 일어나는 일을 크게 두 가지로 나눠볼 수 있다.

- 만약 `watch_queue`(Poll phase가 가지고 있는 큐)가 비어있지 않다면, 큐가 비거나 시스템 최대 실행 한도에 다다를 때까지 동기적으로 모든 콜백을 실행한다.
- 일단 `watch_queue`가 비어있다면, Node.js는 곧바로 다음 페이즈로 넘어가는 것이 아니라 약간 대기시간을 가지게 된다. Node.js가 기다리는 시간은 여러 가지 요인에 따라 계산되는데, 이 부분은 밑에서 따로 설명하도록 하겠다.

**poll** 단계는 두 가지 주요 기능을 가집니다.

1. I/O를 얼마나 오래 블록하고 폴링해야 하는지 계산합니다. 그 다음
2. **poll** 큐에 있는 이벤트를 처리합니다.

이벤트 루프가 **poll** 단계에 진입하고 *스케줄링된 타이머가 없을 때* 두 가지 중 하나의 상황이 발생합니다.

- ***poll** 큐가 **비어있지 않다면*** 이벤트 루프가 콜백의 큐를 순회하면서 큐를 다 소진하거나 시스템 의존적인 하드 한계에 도달할 때까지 동기로 콜백을 실행합니다.

- ***poll** 큐가 **비어있다면*** 다음 중 하나의 상황이 발생합니다.
  - 스크립트가 `setImmediate()`로 스케줄링되었다면 이벤트 루프는 **poll** 단계를 종료하고 스케줄링된 스크립트를 실행하기 위해 **check** 단계로 넘어갑니다.
  - 스크립트가 `setImmediate()`로 스케줄링되지 않았다면 이벤트 루프는 콜백이 큐에 추가되기를 기다린 후 즉시 실행합니다.

**poll** 큐가 일단 비게 되면 타이머가 *시간 임계점에 도달했는지* 확인할 것입니다. 하나 이상의 타이머가 준비되었다면 이벤트 루프는 타이머의 콜백을 실행하기 위해 **timers** 단계로 돌아갈 것입니다.

(6) [**check**](https://github.com/nodejs/node/blob/70ab3108e2d8fa0947a62f8e41675ca1efd160fb/deps/uv/src/unix/core.c#L371) : setImmediate()로 설정된 callback function들을 호출한다.

이 단계는 **poll** 단계가 완료된 직후 사람이 콜백을 실행할 수 있게 합니다. **poll** 단계가 유휴상태가 되고 스크립트가 `setImmediate()`로 큐에 추가되었다면 이벤트 루프를 기다리지 않고 **check** 단계를 계속할 것입니다.

`setImmediate()`는 사실 이벤트 루프의 별도 단계에서 실행되는 특수한 타이머입니다. `setImmediate()`는 **poll** 단계가 완료된 후 콜백 실행을 스케줄링하는데 libuv API를 사용합니다.

보통 코드가 실행되었으므로 이벤트 루프는 들어오는 연결, 요청 등을 기다리는 **poll** 단계에 결국 다다르게 됩니다. 하지만 콜백이 `setImmediate()`로 스케줄링되었고 **poll** 단계가 유휴상태가 되었다면 **poll** 이벤트를 기다리지 않고 **check** 단계로 넘어가게 됩니다.

`Poll phase`의 다음 페이즈는 바로 `setImmediate`의 콜백만을 위한 페이즈인 `Check phase`이다. 이렇게 얘기하면 보통 하시는 질문은, `왜 setImmediate의 콜백만을 위한 큐인가요?`이다. 음, 그건 밑에서 필자가 워크 플로우 섹션에서 다시 얘기할 `Poll phase`에서 수행하는 행동들 때문이기도 하다. 일단 지금은 `Check phase`가 `setImmediate`의 콜백 전용 단계라는 사실만 기억하고 있자.

(7) [**close callbacks**](https://github.com/nodejs/node/blob/70ab3108e2d8fa0947a62f8e41675ca1efd160fb/deps/uv/src/unix/core.c#L372) : *.on(‘close’)로 설정된 callback function들을 호출한다.

소켓이나 핸들이 갑자기 닫힌 경우(예: `socket.destroy()`) 이 단계에서 `'close'` 이벤트가 발생할 것입니다. 그렇지 않으면 `process.nextTick()`으로 실행될 것입니다.

`socket.on('close', () => {})`과 같은 `close` 이벤트 타입의 핸들러들은 여기서 처리된다.

(8) 위의 그림에는 나와있지 않지만, 각 phase사이사이에서 next tick queue와 micro task queue에 들어있는 callback function들을 호출한다.

`nextTickQueue`는 `process.nextTick()` API의 콜백들을 가지고 있으며, `microTaskQueue`는 Resolve된 프로미스의 콜백을 가지고 있다.

이 두개의 큐는 기술적으로 이벤트 루프의 일부가 아니다. 즉, `libUV` 라이브러리에 포함된 것이 아니라 `Node.js`에 포함된 기술이라는 것이다. 이 친구들이 가지고 있는 작업들은 현재 실행되고 있는 작업이 끝나자마자 호출되어야한다.

실제 코드는 [여기서](https://github.com/nodejs/node/blob/70ab3108e2d8fa0947a62f8e41675ca1efd160fb/deps/uv/src/unix/core.c#L359) 확인할 수 있다.



- **timers**: 이 단계는 `setTimeout()`과 `setInterval()`로 스케줄링한 콜백을 실행합니다.
- **pending callbacks**: 다음 루프 반복으로 연기된 I/O 콜백들을 실행합니다.
- **idle, prepare**: 내부용으로만 사용합니다.
- **poll**: 새로운 I/O 이벤트를 가져옵니다. I/O와 연관된 콜백(클로즈 콜백, 타이머로 스케줄링된 콜백, `setImmediate()`를 제외한 거의 모든 콜백)을 실행합니다. 적절한 시기에 node는 여기서 블록 합니다.
- **check**: `setImmediate()` 콜백은 여기서 호출됩니다.
- **close callbacks**: 일부 close 콜백들, 예를 들어 `socket.on('close', ...)`.



## 이벤트 루프의 작업 흐름

우리가 `node my-script.js`를 콘솔에서 실행시켰을 때, Node.js는 이벤트 루프를 생성한 다음 **이벤트 루프 바깥**에서 메인 모듈인 `my-script.js`를 실행한다. 한번 메인 모듈이 실행되고나면 Node.js는 이벤트 루프가 활성 상태인지, 즉 이벤트 루프 안에서 해야할 작업이 있는지를 확인한다. 만약 이벤트 루프를 돌릴 필요가 없다면 Node.js는 `process.on('exit, () => {})`를 실행하고 이벤트 루프를 종료하려고 할 것이다.

그러나 만약 이벤트 루프를 돌려야할 상황이라면 Node.js는 이벤트 루프의 첫 번째 페이즈인 `Timer phase`를 실행한다.

### Timer phase

이벤트 루프가 `Timer phase`에 들어가게 되면 실행할 타이머 콜백 큐에 뭐가 있는 지 확인부터 시작한다. 그냥 확인이라고 하면 간단해보이지만 사실 이벤트 루프는 적절한 콜백들을 찾기 위해 몇 가지 단계를 수행하게된다.
위에서 설명했듯이 타이머 스크립트는 오름차순으로 힙에 저장된다. 그래서 제일 먼저 저장된 타이머들을 하나씩 까서 `now - registeredTime === delta` 같은 조건을 통해 타이머의 콜백을 실행할 시간이 되었는 지 검사하게 된다.(역주: `delta`는 `setTimeout(() => {}, 10)`에서의 `10`)

만약 조건에 해당된다면 이 타이머의 콜백을 실행하고 다음 타이머를 확인한다. 만약 조건에 해당하지 않는 타이머를 만난다면, 탐색을 바로 종료하고 다음 페이즈로 이동한다. 타이머는 힙 내부에 오름차순으로 정렬되어있기 때문에 그 이후로는 탐색을 해도 의미가 없기 때문이다.

자, 예를 들어 딜레이 값이 `100`, `200`, `300`, `400`인 4개의 타이머(A, B, C, D)를 어떤 특정 시간 `t`에 힙에 등록했다고 가정해보자.

이제 이벤트 루프가 `t+250`에 Timer phase에 진입했다고 생각해보자.

가장 먼저 타이머 A를 찾아낸 후 만료 기간이 `t+100`이라는 것을 알게 될 것이다. 그러나 지금은 이미 `t+250`이기 때문에 타이머 A의 콜백은 실행될 것이다. 그리고 타이머 B를 찾아내어 만료 기간이 `t+200`임을 체크하게되고, 타이머 B의 콜백 역시 실행된다.

이제 타이머 C를 체크하게 되는데 이 타이머의 딜레이는 `t+300`이기 때문에 바로 페이즈가 종료된다. 이벤트 루프는 타이머 D는 체크하지 않는데, 위에서 설명했듯이 타이머들은 만료 기간 순으로 오름차순 정렬되어있기 때문에 타이머 C의 뒤쪽에는 어차피 타이머 C보다 만료 기간이 긴 타이머들만 있기 때문이다.

참고로 페이즈는 시스템의 실행 한도에도 영향을 받고 있으므로, 실행 되어야하는 타이머가 아직 남아 있다고 하더라도 시스템 실행 한도에 도달한다면 바로 다음 페이즈로 넘어가게된다

### Pending i/o phase

타임 페이즈가 종료된 후 이벤트 루프는 Pending i/o 페이즈에 진입하고, 가장 먼저 이전 작업들의 콜백이 실행 대기 중인지, 즉 `pending_queue`에 들어와 있는지를 체크하게 된다. 만약 실행 대기 중이라면 `pending_queue`가 비거나 시스템의 실행 한도 초과에 도달할 때까지 대기하고 있던 콜백들을 실행한다. 이 과정이 종료되면 이벤트 루프는 `Idle Handler Phase`로 이동하게 된 후 내부 처리를 위한 `Prepare phase`를 거쳐 최종적으로 가장 중요한 단계인 `Poll Phase`에 도달하게 된다.

### Poll phase

이름에서 알 수 있듯이 이 페이즈는 폴링하는 단계이다. 이벤트 루프가 `Poll phase`에 들어왔을 때 `watcher_queue` 내부에 파일 읽기의 응답 콜백, HTTP 응답 콜백 같이 수행해야 할 작업들이 있다면 이 작업들을 실행하게 된다. 이 과정 또한 `watcher_queue`가 비거나 시스템의 실행 한도 초과에 다다를 때까지 계속 된다.

만약 더 이상 콜백들을 실행할 수 없는 상태가 된다면 만약 `check_queue`, `pending_queue`, `closing_callbacks_queue`에 해야할 작업이 있는지를 검사하고, 만약 해야할 작업이 있다면 바로 `Poll phase`가 종료되고 다음 페이즈로 넘어가게 된다. 하지만 특별히 해야할 작업이 더 이상 없는 경우 `Poll phase`는 다음 페이즈로 넘어가지 않고 계속 대기하게 된다.

이때도 마냥 무한 대기를 하는 것은 아니고, 타이머 힙에서 첫번째 타이머를 꺼내본 다음에 만약 해당 타이머가 실행 가능한 상태라면 그 타이머의 딜레이 시간만큼만 대기 시간을 결정한다.

결국 Poll phase에서 더 이상 수행할 작업이 없는 경우 다음 페이즈로 넘어가는 조건은 다음과 같다.

1. `Check phase`에 실행할 콜백이 있냐? 바로 다음 페이즈로 고고
2. `Check phase`에도 실행할 콜백이 없어? 그럼 타이머는 있어? 있다면 그 타이머를 실행 할 수 있는 시간이 될 때까지만 대기하고 바로 Timer phase로 고고
3. 없어? 그럼 일 생길 때까지 대기…

2번 조건에서 타이머가 있다고 바로 Timer phase로 넘어가지 않고 대기하는 이유는, 대기하지않고 바로 Timer phase로 넘어갈 경우 어차피 첫번째 타이머를 실행할 수 있는 시간이 안되었기 때문에 Timer phase에서도 아무것도 수행하지 않고 Timer phase가 끝나버리기 때문이다. 그렇게 되면 굳이 이벤트 루프를 한번 더 돌아야지 해당 타이머를 실행할 수 있게되므로 그냥 Poll phase에서 대기하는 게 더 이득인 것이다.

### Check phase

`Poll phase`가 지나면 이벤트 루프는 바로 `setImmediate()` API의 콜백과 관련이 있는 `Check phase`에 들어서게 된다. 이 페이즈에서는 다른 페이즈와 마찬가지로 큐가 비거나 시스템 실행 한도 초과에 도달할 때까지 계속 해서 `setImmediate`의 콜백들을 실행한다.

### Close callback

`Check Phase`가 종료된 후에, 이벤트 루프의 다음 목적지는 `close`나 `destory` 콜백 타입들을 관리하는 `Close callback`이다.

이벤트 루프가 `Close callback`들과 함께 종료되고나면 이벤트 루프는 다음에 돌아야할 루프가 있는지 다시 체크 하게 된다. 만약 아니라면 그대로 이벤트 루프는 종료된다. 하지만 만약 더 수행해야할 작업들이 남아 있다면 이벤트 루프는 다음 순회를 돌기 시작하고 다시 `Timer Phase`부터 시작하게 된다.

아까 위에서 설명했던 `Timer Phase`에서의 예시를 다시 가져오자면, 이제 다음 루프의 `Timer Phase`에서는 타이머 C의 만료 시간이 경과했는지부터 확인을 시작할 것이다.

### nextTickQueue & microTaskQueue

근데 이벤트 루프의 일부가 아닌 이 두 큐에 들어있는 콜백들은 언제 실행되는 걸까? 이 두 큐의 콜백들은 어떤 페이즈에서 다음 페이즈로 넘어가기 전에 자신이 가지고 있는 콜백들을 최대한 빨리 실행해야하는 역할을 맡고 있다.(역주: 페이즈에서 다른 페이즈로 넘어가는 과정을 Tick이라고 부른다.)

다른 페이즈들과는 다르게 이 두 큐는 시스템 실행 한도 초과에 영향을 받지 않기 때문에 Node.js는 이 큐가 완전히 비워질 때까지 콜백들을 실행한다. 그리고 `nextTickQueue`는 `microTaskQueue`보다는 높은 우선 순위를 가지고 있다.

### Thread-pool

필자가 자바스크립트 개발자에게 가장 많이 들은 단어는 바로 `스레드풀(ThreadPoll)`이다. 그리고 이와 관련된 가장 큰 오해는 바로 Node.js가 모든 비동기 명령을 관리하는 별도의 스레드풀을 가지고 있다는 것이다. 그러나 이 스레드풀은 Node.js가 아니라 Node.js가 비동기 작업을 처리하기 위해 사용하는 라이브러리인 `libUV`에 포함된 기능이라는 것이다.
필자가 이벤트 루프의 다이어그램에 스레드풀을 별도로 표시하지 않은 이유는 스레드풀 자체가 이벤트 루프 매커니즘의 일부가 아니기 때문이다. `libUV`는 OS커널의 비동기 API만을 사용하여 이벤트 드리븐을 유도할 수 있을 만큼 충분히 훌륭하다. 그러나 파일 읽기, DNS Lookup 등 OS 커널이 비동기 API를 지원하지않는 작업들의 경우에는 별도의 스레드풀을 사용하게 되는데, 이때 기본 값으로 4개의 스레드를 사용하도록 설정되어있다. `uv_threadpool` 환경 변수를 사용하면 최대 128개까지 스레드 개수를 늘릴 수도 있다.

## Multi Thread

nodejs는 single-thread이다. 하지만, 이것은 event-loop와 내 javascript코드를 실행할때만 맞는말이고, 실제로는 아래와 같은 경우에는 다른 thread를 추가적으로 사용한다.

(1) 암호만들기(crypto 모듈) : CPU를 많이 사용해서 Event Loop가 Block될 수 있기 때문에 thread를 사용한다

(2) 비동기 file I/O : Network I/O와는 다르게 OS가 비동기적으로 지원하지 않기때문에 thread를 사용한다

둘다 너무 오래 걸리거나 언제 끝날지 모르기 때문에, event loop가 block되는걸 막기 위해서 thread를 사용하는것이다.

nodejs의 비동기 I/O 추상화 라이브러리인 Libuv는 기본적으로 4개의 thread를 가지고 있다(추가 가능). 내가 fs 모듈의 readFile()함수나, crypto 모듈의 pbkdf2()함수를 사용하면 내부적으로 이런 작업들을 thread를 사용해서 처리한다. thread도 이벤트 루프처럼 안에서 work queue를 감시하는 loop가 돌고있고,

1. 내가 index.js 에서 fs.readFile()을 사용하면
2. 저 work queue에 내 요청이 담기고
3. thread가 그것을 빼내서(원래 loop를 돌면서 work queue를 감시하고 있었으니까) 실행하고 OS에게 일을 맡긴다
4. OS가 일 끝났다고 OS프로세스의 버퍼에서 읽어들인 파일 Data를 가져가라고 하면
5. thread는 watcher queue에 들어있는 내 read요청에 파읽 읽기를 완료했다고 적어놓는다.
6. 위 그림의 poll단계에서는 이 watcher queue를 감시하면서 변화(준비-> 완료)가 있는 **요청**의 callback function을 호출한다.

(사실 위처럼 심플하지는 않고, open -> stat -> read -> close 이런 과정을 거쳐서 마지막에 내 callback function이 호출된다)

Multi Thread에 관한 추가적인 내용은 [[NodeJS\] nodejs는 single-thread가 아니다](https://medium.com/@rpf5573/nodejs-nodejs는-single-thread가-아니다-f02b0278c390) 에서 확인 가능하며, readFile에 관한 내용은 [NodeJS] fs.readFile() 추적기(작성중..) 에서 확인 가능하다.



그림에는 나와있지 않지만, node index.js를 터미널에서 치면 내 index.js파일을 먼저 실행하고, libuv의 uv_run()을 실행한다. 그 안에서 여러 phase를 거친다. setTimeout() 이나 setInterval()로 설정된 callback function이 들어있는 **timer phase**, I/O Operation callback function이 들어있는 pending queue를 돌리는 **pending phase**, I/O Operation상태를 감시하여 I/O 관련 callback을 바로 호출하거나 다음 루프로 지연시키는 **poll phase**, setImmediate로 설정한 callback function이 담겨있는 queue를 돌리는 **check phase**, *.on(‘close’)로 설정한 callback function이 담겨있는 close handler queue를 돌리는, **close phase**를 마지막으로 거친다. 또한 각 phase 사이사이마다 next tick queue & micro task queue를 돌린다. Event loop를 block시킬 수 있는 작업들은 thread Pool의 thread에서 시키고, Network I/O작업은 OS에게 맡긴다. 또 이 work thread와 event loop가 돌아가는 main thread는 worker queue를 통해서 소통한다(pipe라는 기능을 쓴다는데 정확히는 잘 모르겠다).



`setImmediate()`와 `setTimeout()`은 비슷하지만 호출된 시기에 따라 다르게 동작합니다.

- `setImmediate()`는 현재 **poll** 단계가 완료되면 스크립트를 실행하도록 설계되었습니다.
- `setTimeout()`는 최소 임계 값(ms)이 지난 후 스크립트가 실행되도록 스케줄링합니다.

타이머가 실행되는 순서는 어떤 컨텍스트에서 호출되었는지에 따라 다양합니다. 둘 다 메인 모듈 내에서 호출된다면 프로세서의 성능에 따라 달라집니다.(머신에서 실행되는 다른 애플리케이션의 영향을 받을 수 있습니다.)

예를 들어 I/O 주기 내에 있지 않은 컨텍스트(예: 메인 모듈)에서 다음 스크립트를 실행한다면 두 타이머의 순서는 프로세스 성능에 영향을 받으므로 결정적이지 않습니다.

```
// timeout_vs_immediate.js
setTimeout(() => {
  console.log('timeout');
}, 0);

setImmediate(() => {
  console.log('immediate');
});

$ node timeout_vs_immediate.js
timeout
immediate

$ node timeout_vs_immediate.js
immediate
timeout
```

### process.nextTick()

`process.nextTick()`이 비동기 API에 속해있지만, 다이어그램에는 표시되지 않은 것을 눈치챘을 겁니다. 이는 `process.nextTick()`이 기술적으로는 이벤트 루프의 일부가 아니기 때문입니다. 대신 `nextTickQueue`는 이벤트 루프의 현재 단계와 관계없이 현재 작업이 완료된 후에 처리될 것입니다. 여기에서 *작업*이란 기저의 C/C++ 핸들러에서 전환하는 것, 또 실행되어야 하는 JavaScript를 처리하는 것을 말합니다.

다이어그램을 다시 보겠습니다. 해당 단계에서 `process.nextTick()`을 호출하면 `process.nextTick()`에 전달한 모든 콜백은 언제나 이벤트 루프를 계속 진행하기 전에 처리될 것입니다. 이 동작 때문에 재귀로 `process.nextTick()`을 호출하면 이벤트 루프가 **poll** 단계에 다다르는 것을 막아서 **I/O가 "굶주리게" 될 수 있으므로** 좋지 않은 상황을 만들 수 있습니다.

### 왜 이러한 동작을 허용하나요?

왜 이러한 기능이 Node.js에 포함되었는가? 이는 API는 그럴 필요가 없더라도 항상 비동기여야 한다는 설계 철학 때문입니다. 예제로 다음 코드를 보겠습니다.

```
function apiCall(arg, callback) {
  if (typeof arg !== 'string')
    return process.nextTick(callback,
                            new TypeError('argument should be string'));
}
```

위 코드는 인자를 확인한 뒤 제대로 된 인자가 아니면 콜백에 오류를 전달합니다. 최근에 갱신된 API에서는 `process.nextTick()`에 인자를 전달할 수 있게 되어서 콜백뒤에 전달한 인자는 콜백에 대한 인자로 전파되기 때문에 중첩된 함수를 작성할 필요가 없습니다.

여기서는 사용자에게 오류를 다시 전달하고 있지만 *그 후에* 사용자의 남은 코드를 실행할 수 있습니다. `process.nextTick()`을 사용하면 사용자 코드의 나머지 부분 *이후*, 이벤트 루프가 진행되기 *이전*에 항상 `apiCall()`이 콜백을 실행할 수 있게 보장합니다. 이를 위해 JS 호출 스택을 풀고 바로 제공된 콜백을 실행하면서 개발자가 `RangeError: Maximum call stack size exceeded from v8`에 도달하지 않으면서 `process.nextTick()`을 재귀호출할 수 있게 합니다.

이 철학은 잠재적인 문제 상황을 만들 수 있습니다. 다음 예제를 보겠습니다.

```
let bar;

// 비동기 시그니처를 갖지만, 동기로 콜백을 호출합니다.
function someAsyncApiCall(callback) { callback(); }

// `someAsyncApiCall`이 완료되면 콜백을 호출한다.
someAsyncApiCall(() => {
  // someAsyncApiCall는 완료되었지만, bar에는 어떤 값도 할당되지 않았다.
  console.log('bar', bar); // undefined
});

bar = 1;
```

개발자가 `someAsyncApiCall()`을 비동기 시그니처로 정의했지만 실제로는 동기로 동작합니다. 이 함수가 호출되었을 때 `someAsyncApiCall()`가 실제로 비동기로 아무것도 하지 않으므로 `someAsyncApiCall()`에 전달된 콜백은 이벤트 루프의 같은 단계에서 호출됩니다. 그 결과 이 스크립트는 완료까지 실행되지 않았으므로 이 범위에서는 `bar` 변수가 없을 수 있음에도 콜백이 `bar`를 참조하려고 시도합니다.

`process.nextTick()`에 콜백을 두면 모든 변수, 함수 등이 호출되는 콜백보다 먼저 초기화하면서 스크립트를 완료까지 실행할 수 있습니다. 이는 이벤트 루프가 계속 진행되지 않도록 하는 장점도 있습니다. 이벤트 루프가 계속 진행되기 전에 사용자에게 오류 알림을 주는 것이 유용할 수 있습니다. 다음은 앞의 예제를 `process.nextTick()`으로 바꾼 것입니다.

```
let bar;

function someAsyncApiCall(callback) {
  process.nextTick(callback);
}

someAsyncApiCall(() => {
  console.log('bar', bar); // 1
});

bar = 1;
```

다음은 또 다른 예제입니다.

```
const server = net.createServer(() => {}).listen(8080);

server.on('listening', () => {});
```

포트만 전달하면 포트가 바로 바인딩 됩니다. 그래서 `'listening'` 콜백이 바로 호출될 수 있습니다. 문제는 `.on('listening')` 콜백이 이때 설정되지 않는다는 것입니다.

이를 피하려면 `'listening'` 이벤트를 `nextTick()`으로 큐에 넣어서 스크립트가 완료될 때까지 실행되도록 할 수 있습니다. 이를 통해 어떤 이벤트 핸들러라도 설정하도록 할 수 있습니다.

## 왜 `process.nextTick()`을 사용하는가?

두 가지 이유가 있습니다.

1. 사용자가 이벤트 루프를 계속하기 전에 오류를 처리하고 불필요한 자원을 정리하고 요청을 다시 시도할 수 있게 합니다.
2. 호출 스택은 풀린 뒤에도 이벤트 루프를 계속 진행하기 전에 콜백을 실행해야 하는 경우가 있습니다.

한 가지 예는 사용자의 기대를 맞추는 것입니다. 다음은 간단한 예제입니다.

```
const server = net.createServer();
server.on('connection', (conn) => { });

server.listen(8080);
server.on('listening', () => { });
```

`listen()`이 이벤트 루프 시작 부분에서 실행되었지만, listening 콜백은 `setImmediate()`에 있습니다. 바인딩할 호스트네임을 전달하지 않는 한 포트는 즉시 적용될 것입니다. 이벤트 루프를 진행하려면 **poll** 단계에 도달해야 하는데, 이 말은 listening 이벤트 전에 connection 이벤트가 발생하도록 해서 연결을 받을 가능성이 있다는 것입니다.

또 다른 예제는 `EventEmitter`를 상속받고 생성자 내에서 이벤트를 호출하고자 하는 함수 생성자를 실행하는 것입니다.

```js
const EventEmitter = require('events');
const util = require('util');

function MyEmitter() {
  EventEmitter.call(this);
  this.emit('event');
}
util.inherits(MyEmitter, EventEmitter);

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
  console.log('an event occurred!');
});
```

사용자가 콜백을 이벤트에 할당한 시점에 스크립트가 실행되는 것이 아니므로 생성자에서 발생시킨 이벤트는 즉시 실행되지 않습니다. 그러므로 기대하는 결과대로 생성자 안에서 생성자가 완료된 후 이벤트를 발생시키는 콜백을 설정하려고 `process.nextTick()`을 사용할 수 있습니다.

```js
const EventEmitter = require('events');
const util = require('util');

function MyEmitter() {
  EventEmitter.call(this);

  // 핸들러가 할당되면 이벤트를 발생시키려고 nextTick을 사용합니다.
  process.nextTick(() => {
    this.emit('event');
  });
}
util.inherits(MyEmitter, EventEmitter);

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
  console.log('an event occurred!');
});
```

### Process.nextTick() vs. setImmediate()

- `process.nextTick()`은 같은 단계에서 바로 실행됩니다.
- `setImmediate()`는 이어진 순회나 이벤트 루프의 'tick'에서 실행됩니다.

사실 이름은 서로 바뀌어야 합니다. `process.nextTick()`이 `setImmediate()`보다 더 즉시 실행되지만, 이는 바뀔 가능성이 없는 과거의 유산입니다. 이 둘을 바꾼다면 수많은 npm 패키지가 깨질 것입니다. 매일같이 새로운 모듈이 추가되고 있으므로 잠재적인 손상은 더 많이 발생할 것입니다. 이 둘은 혼란스럽지만 이름이 바뀌진 않을 것입니다.

*`setImmediate()`가 예상하기 더 쉬우므로 모든 경우에 `setImmediate()`를 사용하기를 권장합니다.*







https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/



### 왜 우리는 setTimeout(fn, 0)가 있는데도 setImmediate를 사용해야 하나요?

일단, `setTimeout(fn, 0)`은 실질적으로 0이 아니다. 이건 사실 1이다. 여러분이 타이머의 딜레이를 `1ms`보다 작거나 `2147483647ms`보다 크게 설정하면 딜레이는 자동으로 `1`로 세팅된다. 그렇기 때문에 `setTimeout`의 딜레이를 `0`으로 설정하려고 한다면 이 딜레이는 자동으로 `1`이 되는 것이다.

이미 설명했던 대로 `setImmediate`을 사용하면 타이머를 사용할 때처럼 딜레이의 시간이 지났지 뭐니 하는 추가적인 체크 로직이 필요없어진다. 그래서 `setImmediate`은 빠른 것이다. 또한 `setImmediate`의 체크 작업은 Poll phase 직후에 수행되기 때문에 HTTP 요청 콜백과 같은 곳에서 사용된 `setImmediate`의 콜백 함수는 바로 실행된다고 할 수 있다.

### 그럼 자바스크립트는 정확히 어디에서 실행되는건가요?

이 포스트를 처음 읽을 때는 자바스크립트가 정확히 어디서 실행되는지 헷갈릴 수 있다.

앞서 말했듯이 이벤트 루프 자체에서 V8 또는 다른 엔진을 사용하여 자바스크립트를 실행하는 것이고 이때, 단 하나의 스레드를 사용하여 자바스크립트가 실행되는 것이다. 실행 자체는 동기적이고, 현재 실행시킨 자바스크립트의 실행이 완료되지 않는다면 이벤트 루프 또한 진행되지 않는다.



### Snippet 2 – 타이머들을 더 잘 이해하기

```
var i = 0;
var start = new Date();
function foo () {
    i++;
    if (i < 1000) {
        setImmediate(foo);
    } else {
        var end = new Date();
        console.log("Execution time: ", (end - start));
    }
}
foo();
```

위의 예시는 굉장히 간단하다. 함수 `foo`는 `setImmediate()`에 의해서 1000번 재귀호출되고 있다. 이 코드를 필자의 맥북 프로에서 Node.js 8.9.1을 사용하여 실행하면 함수가 종료되기까지 `6~8ms`정도가 걸린다. 이제 위의 스니펫을 `setImmediate(foo)`에서 `setTimeout(foo, 0)`으로 변경해보자.

```
var i = 0;
var start = new Date();
function foo () {
    i++;
    if (i < 1000) {
        setTimeout(foo, 0);
    } else {
        var end = new Date();
        console.log("Execution time: ", (end - start));
    }
}
foo();
```

이제 필자의 컴퓨터에서 이 코드가 실행되는데 걸리는 시간은 대략 `1400+ ms`정도이다.

왜 이렇게 되는걸까? 이 두 경우 모두 폴링에 걸리는 시간은 `0`이기 때문에 동일하게 작동해야한다. 근데 왜 이렇게 실행 시간이 많이 차이가 나게 된 걸까?

그 이유는 바로 시간을 비교하고 편차를 알아내는 작업이 CPU를 집중적으로 사용하는 작업이기 때문에 시간이 더 오래 걸리기 때문이다. 그리고 타이머 스크립트를 등록하는 것 자체도 시간을 소모한다. 위에서 설명했듯이 Timer phase에서는 타이머를 실행할 시간이 되었는지, 콜백을 실행해야 하는지를 검사하기 위해 몇가지 작업을 거쳐야 하는데 이 과정을 매 이터레이션마다 하고 있으니 느려질 수 밖에 없다. 그러나 `setImmediate`의 경우 이런 과정이 필요없기 때문에 `setTimeout`보다 실행 속도가 빠른 것이다.

### Snippet 3 – nextTick()과 타이머 실행에 대해 이해하기

```
var i = 0;
function foo(){
  i++;
  if(i>20){
    return;
  }
  console.log("foo");
  setTimeout(()=>{
    console.log("setTimeout");
  },0);
  process.nextTick(foo);
}   
setTimeout(foo, 2);
```

위 코드의 로그는 어떻게 출력될까? 첫번째 출력은 `foo`들이 될 것이고 기 후 `setTimeout`들이 출력된다. 제일 처음 코드를 실행하면 2ms 후에 첫 번째 `foo`가 출력되고 다음 `nextTickQueue`에 다시 `foo()`를 넣게된다. 그리고 `nextTickQueue`에 들어간 콜백들은 한 페이즈에서 다음 페이즈로 넘어갈 때마다 무조건 콜백들을 동기적으로 실행해야한다. 그렇기 때문에 재귀호출로 `nextTickQueue`에 들어간 모든 콜백들을 실행하고 나서야 Timer Phase에서 `setTimeout` 콜백을 처리할 수 있게 되는 것이다.

코드를 약간 수정하고 다시 살펴보자.

```
var i = 0;
function foo(){
  i++;
  if(i>20){
    return;
  }
  console.log("foo", i);
  setTimeout(()=>{
    console.log("setTimeout", i);
  },0);
  process.nextTick(foo);
}

setTimeout(foo, 2);
setTimeout(()=>{
  console.log("Other setTimeout");
}, 2);
```

필자는 기존의 `setTimeout`과 같은 딜레이 시간을 가진 `setTimeout`을 추가했고, 이 타이머의 콜백은 단지 `Other setTimeout`을 출력하기만 한다. 뭐, 확실하다고 말할 수는 없지만 한 개의 `foo`가 먼저 출력된 후 `Other setTimeout`이 출력될 찬스가 존재하긴 한다. 타이머들이 들어있는 힙 내부에 동일한 딜레이를 가진 타이머들은 어떻게든 그룹화되어있고, `nextTickQueue`의 체크는 진행 중인 콜백 그룹의 실행이 끝난 후에야 진행되기 때문이다.

> **역주**: 첫 번째 setTimeout의 콜백과 두 번쨰 setTimeout의 콜백이 실행될 시간이 동일하기 때문에 Timer phase에서 두 타이머의 콜백이 모두 큐에 들어갔고, 일단 큐에 들어갔으면 시스템 실행 한도에 걸리지 않는 이상 무조건 해당 페이즈가 끝나기 전에 실행된다.
>
> 이런 경우, `foo()` 내부의 `process.nextTick`의 콜백은 Timer phase에서 다음 페이즈로 넘어갈 때 실행될 것이기 때문에 `foo`가 먼저 한 개 출력되고 `Other setTimeout`이 출력되는 것이다.



각 단계 사이에서 libuv는 단계 결과를 상위 계층의 노드 아키텍처 (JavaScript를 의미 함)와 통신해야합니다. 이런 일이 생길 때마다`process.nextTick` 콜백 및 기타 마이크로 태스크 콜백이 실행됩니다.



> **I / O 란 무엇입니까?**
>
> 일반적으로 CPU를 제외한 외부 장치와 관련된 모든 작업을 I / O라고합니다. 가장 일반적인 추상 I / O 유형은 파일 작업 및 TCP / UDP 네트워크 작업입니다.

## Libuv 및 NodeJS I / O

JavaScript 자체에는 비동기 I / O 작업을 수행 할 수있는 기능이 없습니다. NodeJS를 개발하는 동안 [libuv](http://docs.libuv.org/) 는 처음에 노드에 비동기 I / O를 제공하기 시작했지만 현재 libuv는 개별적으로 사용할 수있는 독립형 라이브러리로 존재합니다. NodeJS 아키텍처에서 Libuv의 역할은 내부 I / O 복잡성을 추상화하고 상위 계층에 대한 일반화 된 인터페이스를 제공하여 Node가 어떤 플랫폼에서 실행되는지에 대한 걱정없이 플랫폼 독립적 인 비동기 I / O를 수행 할 수 있도록하는 것입니다.

https://blog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1



스레드는 그 자신의 이벤트 루프를 가지고 있고 각각의 web worker 는 자신의 이벤트 루프를 수행하기 때문에 서로 독립적으로 실행된다. 그러나 같은 도메인(origin)의 모든 브라우저 창들은 동기적으로 통신할 수 있기 때문에 이벤트 루프를 서로 공유한다. 이벤트 루프는 지속적으로 돌아가면서, 대기열에 들어가있는 task 들을 실행시킨다. 한 이벤트 루프는 실행 순서를 보장하는 여러개의 task 를 가지고 있지만 각 이벤트 루프의 실행단계에서 어떤 task 를 실행시킬지는 브라우저가 선택한다. 이를 통해 브라우저는 유저 input 과 같은 성능에 민감한 task 에 우선권을 부여할 수 있다.

task 는 브라우저 내부에서 javascript/DOM 으로 들어가 순차적으로 발생하도록 예약된다. task 사이에서 브라우저는 렌더링을 새로한다. 마우스 클릭으로 이벤트 콜백을 발생시키려면 HTML 파싱 처럼 task 예약이 필요하다. 위에서 보았던 `setTimeout`이 좋은 사례이다.

`setTimeout`은 주어진 delay 를 기다린 다음 콜백을 위한 새로운 task 를 예약한다. 이것이 `setTimeout`로그가 `script end`로그 이후에 출력되는 이유이다. `script end`로그는 첫번째 task 의 일부이고 `setTimeout`은 별도의 task 에서 발생한 로그이다.



[https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-4%EA%B0%80%EC%A7%80-%ED%9D%94%ED%95%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EB%8C%80%EC%B2%98%EB%B2%95-5b0d217d788d](https://engineering.huiseoul.com/자바스크립트는-어떻게-작동하는가-메모리-관리-4가지-흔한-메모리-누수-대처법-5b0d217d788d)

[https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-v8-%EC%97%94%EC%A7%84%EC%9D%98-%EB%82%B4%EB%B6%80-%EC%B5%9C%EC%A0%81%ED%99%94%EB%90%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9E%91%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%8B%A4%EC%84%AF-%EA%B0%80%EC%A7%80-%ED%8C%81-6c6f9832c1d9](